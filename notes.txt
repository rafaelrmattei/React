# NOVO PROJETO COM VITE
npm create vite@latest


# INSTALAR AS DEPENDENCIAS
npm i 


# RODAR O PROJETO
npm run dev


# PACOTE DE ÍCONES PHOSPHOR
npm i phosphor-react    


# PACOTE DE MANIPULAÇÃO DE DATAS
npm i date-fns


# STYLED componentes
npm i styled-components
npm i @types/styled-components -D # Como não vem com a tipagem, tem que instalar quando usar o Typescript - O -D quer dizer que é só para o ambiente de desenvolvimento


# JSON Server
- Utilizado para simular um servidor com rotas e tudo mais para o ambiente de desenvolvimento
- npm i json-server@0.17.3 -D (-D quer dizer que é só para o ambiente de desenvolvimento) (0.17.3 por que a ultima versão não tem tudo que tem na .17.3)
- Criar um arquivo json do server no root do projeto. Ex: server.json 
- Rodar o "backend": npx json-server server.json -p 3333 -w -d 1000 (-d 1000 adiciona um delay para simular um ambiente real)
- Colocar um atalho para rodar. No packeg.json em scripts: "scripts": { "dev:server": "json-server server.json -p 3333 -w" } # Assim é só rodar npm run dev:server


# Axios
- npm i axios
- Utilizado para subtituir o fetch por que não tem a API mais amigável do mundo
- criar a pasta src/lib para configuração do axios


# UTILIZANDO ROTAS
npm i react-router-dom
0. Olhar a documentação, pq já foi alterado o formato de uso: https://reactrouter.com/start/data/installation #importante

1 - Criar o arquivo de rotas (Router.tsx) dentro de src
import { Routes, Route } from 'react-router-dom'
import { Home } from './pages/Home'
import { History } from './pages/History'
export function Router() {
  return (
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/history" element={<History />} />
    </Routes>
  )
}

2 - Dentro de App.tsx importar as rotas, e pra funcionar deve-se importar o BrowserRouter do pacote router-dom e colocar o arquivo de rotas (Router) dentro dele
import { BrowserRouter } from "react-router-dom"
import { Router } from "./Router";
export function App() {
  return (
      <BrowserRouter>
        <Router />
      </BrowserRouter>
  )
}


# UTILIZANDO O COMPONENTE OUTLET
import { Outlet } from "react-router-dom"
<Outlet />
É um espaço para ser inserido um conteúdo. 
Exemplo: ao invés de se repetir o header da aplicação, coloca-se ele dentro da pasta layouts num componente onde o entra o Header e o Outlet (que vai receber o conteúdo que muda entre as páginas) http://localhost/
<Routes>
  <Route path="/" element={<DefaultLayout />}> #Deve-se colocar esse elemento Route englobando as rotas que utilização esse layout
    <Route path="/" element={<Home />} />
    <Route path="/history" element={<History />} />
  </Route>
  <Route path="/admin" element={<AdmintLayout />}> #Exemplo de rotas para admin com outro arquivo de layout http://localhost/admin/products
    <Route path="/products" element={<Products />} />
  </Route>
</Routes>


# FORMS (CONTROLLED/UNCONTROLLED)

1 - Controlled são os formulários feitos usando useState que leem cada movimento feito pelo usuário.
-- O problema é que se forem muito grandes o react precisa reconstruir toda interface e pode ficar lento
-- Para formulários menos é ótimo

2 - Uncontrolled são formulários feitos sem o useState, pegando as informações dos inputs somente no onSubmit por Exemplo
-- Para formulários muito grandes não virarem gargalos

3 - Utilizar a biblioteca React Hook Form que utiliza os dois formatos/melhor dos dois mundos
-- npm i react-hook-form
-- import { useForm } from "react-hook-form"
-- const { register, handleSubmit, watch } = useForm()
-- const task = watch('task') <StartCountdownButton type="submit" disabled={!task}> #O watch serve para pegar o valor em tempo real da variável como se fosse usando o useState
-- <TaskInput
      id="task"
      list="task-suggestions"
      placeholder="Dê um nome para o seu projeto"
      {...register('task')} # Esse se transforma no nome do input
    />
    {...register('minutesAmount', { valueAsNumber: true })} #Pode receber um objeto de parametros para dizer por exemplo que é do tipo number
-- const { register, handleSubmit } = useForm()
  function handleCreateNewCycle() {}
  return (
    <HomeContainer>
      <form onSubmit={handleSubmit(handleCreateNewCycle)} action=""> #O onSubmit recebe a funcção do useForm passando como parametro a função que criamos para lidar com o submit

4 - Utilizar a biblioteca para validar o form (yup, joi, zod) #todas são boas, zod é o que o loirinho gosta pq integra melhor com o TS 
-- npm i zod
-- npm i @hookform/resolvers #Permite integrar react-hook-form com as bibliotecas de validação
-- import { zodResolver } from '@hookform/resolvers/zod'
-- import * as zod from 'zod'
-- Utilizando o zod
    const newCycleFormValidationSchema = zod.object({ #Criar uma constante com as regras do formulário
      task: zod.string().min(1, 'Informe a tarefa'),
      minutesAmount: zod.number().min(5).max(60)
    })

    type NewCycleFormData = zod.infer<typeof newCycleFormValidationSchema>

    export function Home() {
      const { register, handleSubmit, watch } = useForm<NewCycleFormData>({
        resolver: zodResolver(newCycleFormValidationSchema)
      })
-- Resetar o form
export function Home() {
  const { register, handleSubmit, watch, reset } = useForm<NewCycleFormData>({ #Adiciona a função de reset aqui
    resolver: zodResolver(newCycleFormValidationSchema),
    defaultValues: {
      task: '',
      minutesAmount: 0
    }
  })

  const task = watch('task')
  const isSubmitDisabled = !task

  function handleCreateNewCycle(data: NewCycleFormData) {
    console.log(data)
    reset() #Chama a função de reset()
  }


# HOOK USEEFFECT
import { useEffect } from 'react'
-- Executa quando carrega a tela e toda vez que uma váriavel que ele está escutando é alterada.
-- Se quiser executar somente uma vez, não passa o segundo parametro. Ex:
useEffect(() => {
  console.log("Primeira renderização") # Bom para fazer uma chamada de api para mostrar dados em tela e depois não executar mais
  fetch('htts://api.github.com/users/diego3g/repos')
    .then(response => response.json())
    .then(data => {
      setList()
    })
}, []) # O segundo parametro fica vazio
-- Como não usar. Não usar para atualizar um estado. Cuidar para não multiplicar o número de renderizações com useState e useEffect juntos


# PROP DRILLING
-- Quando temos MUITAS propriedades APENAS para comunicação entre componentes
-- Solução: CONTEXT API: Permite compartilharmos informações entre VÁRIOS componentes ao mesmo tempo


# CONTEXT
-- Importar do react import { createContext } from "react"
-- Criar contexto: 
  interface Cycle {
    id: string
    task: string
    minutesAmount: number
    startDate: Date
    interruptedDate?: Date
    finishedDate?: Date
  }
  interface CyclesContextType {
    activeCycle: Cycle | undefined
  }
  export const CyclesContext = createContext({} as CyclesContextType) # Deve-se exportar o contexto
-- Englobar os elementos filhos que vão utilizar as variáveis do contexto com <CyclesContext.Provider value={{ activeCycle }}></CyclesContext.Provider>
-- Para utilizar nos filhos:
  import { useContext } from "react"; # Para usar o contexto
  import { CyclesContext } from "../.."; # Que foi exportado do pai 
  const { activeCycle } = useContext(CyclesContext)
-- Usando o useForm() que é uma biblioteca externa não faz muito sentido passar os campos por contexto
  const newCycleForm = useForm<NewCycleFormData>({ # Foi colocado dentro de uma variável
    resolver: zodResolver(newCycleFormValidationSchema),
    defaultValues: {
      task: '',
      minutesAmount: 0
    }
  })
  const { handleSubmit, watch, reset } = newCycleForm # Depois foi desestruturado e removido o register
  <FormProvider {...newCycleForm}> #Adicionado o form provider fora do NewCycleForm que vem do import { FormProvider, useForm } from "react-hook-form", e foi feito o spread das váriaveis do newCycleForm que foi criada
    <NewCycleForm />
  </FormProvider>
  E dentro do elemento filho: 
  import { useFormContext } from "react-hook-form";
  const { register } = useFormContext()

# USEREDUCER 
-- Usado quando a complexidade da troca de um estado (state) é muito complexa 
Isso: const [cycles, setCycles] = useState<Cycle[]>([])
Vira isso: const [cycles, dispatch] = useReducer((state: Cycle[], action: unknown) => {
    return state
  }, [])


#BIBLIOTECA IMMER
-- npm i immer
-- import { produce } from 'immer'
-- Utilizado no lugar dos maps, para não precisar percorrer um array para fazer uma alteração
--// return {
  //   ...state,
  //   cycles: [...state.cycles, action.payload.newCycle],
  //   activeCycleId: action.payload.newCycle.id
  // }
  return produce(state, draft => {
    draft.cycles.push(action.payload.newCycle)
    draft.activeCycleId = action.payload.newCycle.id
  })

  // return {
  //   ...state,
  //   cycles: state.cycles.map(cycle => {
  //     if (cycle.id === state.activeCycleId) {
  //       return { ...cycle, interruptedDate: new Date() }
  //     } else {
  //       return cycle
  //     }
  //   }),
  //   activeCycleId: null

  // }
  const currentCycleIndex = state.cycles.findIndex(cycle => {
    return cycle.id === state.activeCycleId
  })

  if (currentCycleIndex < 0) {
    return state
  }

  return produce(state, draft => {
    draft.cycles[currentCycleIndex].interruptedDate = new Date() 
    draft.activeCycleId = null
  })


# USE CONTEXT SELECTOR (OTIMIZAÇÃO)
- npm i use-context-selector scheduler
- Utilizada para otilização nos contextos. Para não precisar renderizar todo o contexto, e só o que foi chamado dele.
- import { createContext } from "use-context-selector"; # Altera a chamada do createContext do react para o use-context-selector
- import { useContextSelector } from "use-context-selector"; # Altera a chamada do useCOntext para useContextSelector e adiciona um parametro de função de retorno do que é preciso utilizar
  const createTransaction = useContextSelector(
    TransactionContext,
    (context) => {
      return context.createTransaction;
    }
  );

# USE CALLBACK (OTIMIZAÇÃO)
- Vem do react import { useCallback } from 'react' e serve para evitar que uma função seja recriada se nenhuma informação que aquela função dependa tenha mudado
- Isso: 
  async function createTransaction(data: CreateTransactionInput) {
    const { description, price, category, type } = data;

    const response = await api.post("transactions", {
      description,
      price,
      category,
      type,
      createdAt: new Date(),
    });

    setTransactions((state) => [response.data, ...state]);
  }
  Vira isso:
  const createTransaction = useCallback(
    async (data: CreateTransactionInput) => {
      const { description, price, category, type } = data;

      const response = await api.post("transactions", {
        description,
        price,
        category,
        type,
        createdAt: new Date(),
      });

      setTransactions((state) => [response.data, ...state]);
    },
    [] # Aqui é um array de dependencias que precisa ser adicionados quando a função depende de uma variavel externa
  );

# MEMO (OTIMIZAÇÃO)
 - Utilizando em componentes que tem HTML muito pesado, exemplo: Longas listas.
 - Não utilizar em tudo, porque a comparação dele demora mais tempo do que a comparação normal do react. É somente para locais com HTML realmente pesados.
 - Uso em funções:
 - Isso:
  export function SearchFormComponent() {}
 - Vira isso:
  function SearchFormComponent() {}
  export const SearchForm = memo(SearchFormComponent);
 - Uso em variaveis: #summary só vai recalcular quando transactions mudar
  const summary = useMemo(() => {
    return transactions.reduce(
      (acc, transaction) => {
        if (transaction.type === "income") {
          acc.income += transaction.price;
          acc.total += transaction.price;
        } else {
          acc.outcome += transaction.price;
          acc.total -= transaction.price;
        }

        return acc;
      },
      {
        income: 0,
        outcome: 0,
        total: 0,
      }
    );
  }, [transactions]);
  

# SHADCN/UI (https://ui.shadcn.com)
- Biblioteca de componentes que utiliza tailwind

# ESLINT 
- npm i eslint @rocketseat/eslint-config -D
- Cria-se o arquivo .eslintrc.json e adiciona:
  {
    "extends": ["@rocketseat/eslint-config/react"],
  }

# PRETTIER TAILWIND (https://tailwindcss.com/blog/automatic-class-sorting-with-prettier)
- Organiza a ordem das classes tailwind
- npm install -D prettier prettier-plugin-tailwindcss
- Cria-se o arquivo de configuração .prettierrc e adiciona:
  {
  "plugins": ["prettier-plugin-tailwindcss"]
  }

# PLUGIN REODENAÇÃO DE IMPORTS E EXPORTS/opctional (https://github.com/lydell/eslint-plugin-simple-import-sort)
- Reordena as importações para ficar mais bem padronizado
- npm i -D eslint-plugin-simple-import-sort
- Adiciona ao arquivo .eslintrc.json:
  {
    "extends": ["@rocketseat/eslint-config/react"],
    "plugins": ["simple-import-sort"] # isso aqui
    "rules": { # isso aqui
      "simple-import-sort/imports": "error" # isso aqui
    } # isso aqui
  }
- Adicionar ao settings.json do vscode:
  "editor.formatOnSave": true,
  "editor.formatOnPaste": true,
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit",
    "source.fixAll.eslint": "explicit"
  },
  "eslint.validate": ["javascript", "typescript", "javascriptreact", "typescriptreact"]


# RECHARTS 
- Biblioteca de charts/gráficos
- npm i recharts


# REACT QUERY
- npm i @tanstack/react-query
  lib/react-query.ts:
  import { QueryClient } from '@tanstack/react-query'
  export const queryClient = new QueryClient()
  App.tsx:
  <QueryClientProvider client={queryClient}>
    <RouterProvider router={router} />
  </QueryClientProvider>


# TESTES
- Vitest: https://vitest.dev
- Testing https://testing-library.com
- Happydom https://github.com/capricorn86/happy-dom
- npm i -D @testing-library/user-event


# MSW
- https://mswjs.io
- npm i msw -D
- Construção de Mocks. 
- Serve para operar a aplicação sem precisar conectar na API.


# DESIGN SYSTEM
- Criar pacotes com padrões de design como cores, fontes, e etc para serem usados em diversos projetos
- npm init -y: Cria o package.json
- npm i -D typescript: Instala o typescript
- npx tsc --init: Cria o arquivo de configuração do typescript
- npx tsx: Inicia o projeto transformando os arquivos ts em js
- Estrutura de pastas: 
-- packages\
--- tokens\
---- package.json
---- package-lock.json
---- tsconfig.json
---- src\
----- colors.ts #variáveis usando a linguagem mais abrangente possível para atingir qualquer tecnologia que vá importar
----- index.ts #exportando o colors.ts